{{define "golang"}}
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package {{.Package}}

import (
    "math/big"
    "strings"

    "../contracts"
    {{range $name, $import := .Imports}}{{$name}} "{{$import}}"
    {{end}})

{{$contract := .Contract}}
{{$structs := .Contract.Structs}}

//go:generate mockgen -source {{toSnakeCase $contract.Type}}.go -destination ./mocks/mock_{{toSnakeCase $contract.Type}}.go -package mocks I{{$contract.Type}}Manager,I{{$contract.Type}}Contract
type I{{$contract.Type}}Manager interface {
    Address() common.Address
    TxHash() common.Hash
    CreatedAt() *big.Int

    // Call methods
    I{{$contract.Type}}Calls

    // Transact methods
    {{range $contract.Transacts}}{{.Normalized.Name}}(
        ctx context.Context,
        opts *blockchain.TransactOpts,
        {{range .Normalized.Inputs}}{{.Name}} {{bindtype .Type $structs}},
        {{end}}) ({{if .Structured}}struct{
        {{range .Normalized.Outputs}}{{.Name}} {{bindtype .Type $structs}};
        {{end}}
    },{{else}}{{range .Normalized.Outputs}}
        {{bindtype .Type $structs}},{{end}}
        {{end}} error,
    )
    {{end}}

    // Event methods
    I{{$contract.Type}}Filterer
    I{{$contract.Type}}Watcher
}

type I{{$contract.Type}}Calls interface { {{range $contract.Calls}}
    {{.Normalized.Name}}({{range .Normalized.Inputs}}
        {{.Name}} {{bindtype .Type $structs}},{{end}}
    ) ({{if .Structured}}struct{
        {{range .Normalized.Outputs}}{{.Name}} {{bindtype .Type $structs}};
        {{end}}
    },{{else}}{{range .Normalized.Outputs}}
        {{bindtype .Type $structs}},{{end}}
    {{end}} error,
    ){{end}}
}

type I{{$contract.Type}}Transacts interface { {{range $contract.Transacts}}
    {{.Normalized.Name}}(
        ctx context.Context,
        opts *blockchain.TransactOpts,
        {{range .Normalized.Inputs}}{{.Name}} {{bindtype .Type $structs}},
    {{end}}) (*chainTypes.Receipt, error){{end}}
}

type I{{$contract.Type}}Events interface {
    I{{$contract.Type}}Filterer
    I{{$contract.Type}}Parser
    I{{$contract.Type}}Watcher
}

type I{{$contract.Type}}Filterer interface { {{range $contract.Events}}
    Filter{{.Normalized.Name}}(
        opts *bind.FilterOpts,
        {{range .Normalized.Inputs}}{{if .Indexed}}{{.Name}} []{{bindtype .Type $structs}},{{end}}
    {{end}}) (*contracts.{{$contract.Type}}{{.Normalized.Name}}Iterator, error){{end}}
}

type I{{$contract.Type}}Parser interface { {{range $contract.Events}}
    Parse{{.Normalized.Name}}(log chainTypes.Log) (*contracts.{{$contract.Type}}{{.Normalized.Name}}, error)
    Parse{{.Normalized.Name}}FromReceipt(receipt *chainTypes.Receipt) ([]*contracts.{{$contract.Type}}{{.Normalized.Name}}, error){{end}}
}

type I{{$contract.Type}}Watcher interface { {{range $contract.Events}}
    Watch{{.Normalized.Name}}(
        opts *bind.WatchOpts,
        sink chan<- *contracts.{{$contract.Type}}{{.Normalized.Name}},
        {{range .Normalized.Inputs}}{{if .Indexed}}{{.Name}} []{{bindtype .Type $structs}},{{end}}
    {{end}}) (event.Subscription, error){{end}}
}

type I{{$contract.Type}}Contract interface {
    Address() common.Address
    TxHash() common.Hash
    CreatedAt() *big.Int

    I{{$contract.Type}}Calls
    I{{$contract.Type}}Transacts
    I{{$contract.Type}}Events
}

// Manager is contract wrapper struct
type {{$contract.Type}}Contract struct {
    address   common.Address
    txHash    common.Hash
    createdAt *big.Int
    client    blockchain.TxClient

    contracts.{{$contract.Type}}Caller
    contracts.{{$contract.Type}}Filterer
    contracts.{{$contract.Type}}Transactor
}

// Address is getter method of Accounts.address
func (c *{{$contract.Type}}Contract) Address() common.Address {
    return c.address
}

// TxHash is getter method of Accounts.txHash
func (c *{{$contract.Type}}Contract) TxHash() common.Hash {
    return c.txHash
}

// CreatedAt is getter method of Accounts.createdAt
func (c *{{$contract.Type}}Contract) CreatedAt() *big.Int {
    return c.createdAt
}

func new{{$contract.Type}}Contract(address common.Address, txHash common.Hash, createdAt *big.Int, parsedABI abi.ABI, backend bind.ContractBackend) interface{} {
    contract := blockchain.NewBoundContract(address, parsedABI, backend, backend, backend)

    return &{{$contract.Type}}Contract{
        address:   address,
        txHash:    txHash,
        createdAt: createdAt,
        client:    backend.(blockchain.TxClient),

        {{$contract.Type}}Caller: contracts.New{{$contract.Type}}Caller(contract),
        {{$contract.Type}}Transactor: contracts.New{{$contract.Type}}Transactor(contract),
        {{$contract.Type}}Filterer: contracts.New{{$contract.Type}}Filterer(contract),
    }
}

// convenient hacks for blockchain.Client
func init() {
    blockchain.AddContractConstructor("{{$contract.Type}}", new{{$contract.Type}}Contract)
    {{range $contract.Transacts}}blockchain.RegisterSelector("0x{{printf "%x" .Original.ID}}", "{{.Original.Sig}}")
{{end}}}

{{range $contract.Calls}}
// {{.Normalized.Name}} is a free data retrieval call binding the contract method 0x{{printf "%x" .Original.ID}}.
//
// Solidity: {{.Original.String}}
func (c *{{$contract.Type}}Contract) {{.Normalized.Name}}(
    {{range .Normalized.Inputs}}{{.Name}} {{bindtype .Type $structs}},
{{end}}) (
    {{if .Structured}}struct{
        {{range .Normalized.Outputs}}{{.Name}} {{bindtype .Type $structs}};
        {{end}}
    },{{else}}{{range .Normalized.Outputs}}
        {{bindtype .Type $structs}},{{end}}
    {{end}} error,
) {
    return c.{{$contract.Type}}Caller.{{.Normalized.Name}}(nil{{range .Normalized.Inputs}}, {{.Name}}{{end}})
}
{{end}}

{{range $contract.Transacts}}
// {{.Normalized.Name}} is a paid mutator transaction binding the contract method 0x{{printf "%x" .Original.ID}}.
//
// Solidity: {{.Original.String}}
func (c *{{$contract.Type}}Contract) {{.Normalized.Name}}(
    ctx context.Context,
    opts *blockchain.TransactOpts,
    {{range .Normalized.Inputs}}{{.Name}} {{bindtype .Type $structs}},
{{end}}) (*chainTypes.Receipt, error) {
    if opts == nil {
        opts = &blockchain.TransactOpts{TxType: chainTypes.TxTypeSmartContractExecution}
    }

    tx, err := c.{{$contract.Type}}Transactor.{{.Normalized.Name}}(c.client.Account(ctx, opts){{range .Normalized.Inputs}}, {{.Name}}{{end}})

    if err != nil {
        return nil, err
    }
    return c.client.WaitMined(ctx, tx)
}
{{end}}{{end}}