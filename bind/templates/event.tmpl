{{define "Events"}}{{$contract := .}}
{{range .Events}}
    // {{$contract.Type}}{{.Normalized.Name}}Iterator is returned from Filter{{.Normalized.Name}} and is used to iterate over the raw logs and unpacked data for {{.Normalized.Name}} events raised by the {{$contract.Type}} contract.
    type {{$contract.Type}}{{.Normalized.Name}}Iterator struct {
        Event *{{$contract.Type}}{{.Normalized.Name}} // Event containing the contract specifics and raw log

        contract *bind.BoundContract // Generic contract to use for unpacking event data
        event    string              // Event name to use for unpacking event data

        logs chan ethTypes.Log        // Log channel receiving the found contract events
        sub  ethereum.Subscription // Subscription for errors, completion and termination
        done bool                  // Whether the subscription completed delivering logs
        fail error                 // Occurred error to stop iteration
    }

    // Next advances the iterator to the subsequent event, returning whether there
    // are any more events found. In case of a retrieval or parsing error, false is
    // returned and Error() can be queried for the exact failure.
    func (it *{{$contract.Type}}{{.Normalized.Name}}Iterator) Next() bool {
        // If the iterator failed, stop iterating
        if (it.fail != nil) {
            return false
        }
        // If the iterator completed, deliver directly whatever's available
        if (it.done) {
            select {
            case log := <-it.logs:
                it.Event = new({{$contract.Type}}{{.Normalized.Name}})
                if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
                it.fail = err
                    return false
                }
                it.Event.Raw = log
                return true

            default:
                return false
            }
        }
        // Iterator still in progress, wait for either a data or an error event
        select {
        case log := <-it.logs:
            it.Event = new({{$contract.Type}}{{.Normalized.Name}})
            if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
                it.fail = err
                return false
            }
            it.Event.Raw = log
            return true

        case err := <-it.sub.Err():
            it.done = true
            it.fail = err
            return it.Next()
        }
    }

    // Error returns any retrieval or parsing error occurred during filtering.
    func (it *{{$contract.Type}}{{.Normalized.Name}}Iterator) Error() error {
        return it.fail
    }
    // Close terminates the iteration process, releasing any pending underlying
    // resources.
    func (it *{{$contract.Type}}{{.Normalized.Name}}Iterator) Close() error {
        it.sub.Unsubscribe()
        return nil
    }

    // {{$contract.Type}}{{.Normalized.Name}} represents a {{.Normalized.Name}} event raised by the {{$contract.Type}} contract.
    type {{$contract.Type}}{{.Normalized.Name}} struct { {{range .Normalized.Inputs}}
        {{capitalise .Name}} {{if .Indexed}}{{bindtopictype .Type $contract.TypeOption}}{{else}}{{bindtype .Type $contract.TypeOption}}{{end}}; {{end}}
        Raw ethTypes.Log // Blockchain specific contextual infos
    }

    // Filter{{.Normalized.Name}} is a free log retrieval operation binding the contract event 0x{{printf "%x" .Original.Id}}.
    //
    // Solidity: {{.Original.String}}
    func (_{{$contract.Type}} *{{$contract.Type}}Filterer) Filter{{.Normalized.Name}}(opts *bind.FilterOpts{{range .Normalized.Inputs}}{{if .Indexed}}, {{.Name}} []{{bindtype .Type $contract.TypeOption}}{{end}}{{end}}) (*{{$contract.Type}}{{.Normalized.Name}}Iterator, error) {
        {{range .Normalized.Inputs}}
        {{if .Indexed}}var {{.Name}}Rule []interface{}
        for _, {{.Name}}Item := range {{.Name}} {
            {{.Name}}Rule = append({{.Name}}Rule, {{.Name}}Item)
        }{{end}}{{end}}

        logs, sub, err := _{{$contract.Type}}.contract.FilterLogs(opts, "{{.Original.Name}}"{{range .Normalized.Inputs}}{{if .Indexed}}, {{.Name}}Rule{{end}}{{end}})
        if err != nil {
            return nil, err
        }
        return &{{$contract.Type}}{{.Normalized.Name}}Iterator{contract: _{{$contract.Type}}.contract, event: "{{.Original.Name}}", logs: logs, sub: sub}, nil
    }

    // Filter{{.Normalized.Name}} parses the event from given transaction receipt.
    //
    // Solidity: {{.Original.String}}
    func (manager *{{$contract.Type}}Contract) Parse{{.Normalized.Name}}FromReceipt(receipt *ethTypes.Receipt) (*{{$contract.Type}}{{.Normalized.Name}}, error) {
        return manager.contract.Parse{{.Normalized.Name}}FromReceipt(receipt)
    }

    // Filter{{.Normalized.Name}} parses the event from given transaction receipt.
    //
    // Solidity: {{.Original.String}}
    func (_{{$contract.Type}} *{{$contract.Type}}Filterer) Parse{{.Normalized.Name}}FromReceipt(receipt *ethTypes.Receipt) (*{{$contract.Type}}{{.Normalized.Name}}, error) {
        for _, log := range receipt.Logs {
            if log.Topics[0] == common.HexToHash("0x{{printf "%x" .Original.Id}}") {
                event := new({{$contract.Type}}{{.Normalized.Name}})
                if err := _{{$contract.Type}}.contract.UnpackLog(event, "{{.Original.Name}}", *log); err != nil {
                    return nil, err
                }
                return event, nil
            }
        }
        return nil, errors.New("{{.Original.Name}} event not found")
    }

    // Watch{{.Normalized.Name}} is a free log subscription operation binding the contract event 0x{{printf "%x" .Original.Id}}.
    //
    // Solidity: {{.Original.String}}
    func (_{{$contract.Type}} *{{$contract.Type}}Filterer) Watch{{.Normalized.Name}}(opts *bind.WatchOpts, sink chan<- *{{$contract.Type}}{{.Normalized.Name}}{{range .Normalized.Inputs}}{{if .Indexed}}, {{.Name}} []{{bindtype .Type $contract.TypeOption}}{{end}}{{end}}) (event.Subscription, error) {
        {{range .Normalized.Inputs}}
        {{if .Indexed}}var {{.Name}}Rule []interface{}
        for _, {{.Name}}Item := range {{.Name}} {
            {{.Name}}Rule = append({{.Name}}Rule, {{.Name}}Item)
        }{{end}}{{end}}

        logs, sub, err := _{{$contract.Type}}.contract.WatchLogs(opts, "{{.Original.Name}}"{{range .Normalized.Inputs}}{{if .Indexed}}, {{.Name}}Rule{{end}}{{end}})
        if err != nil {
            return nil, err
        }
        return event.NewSubscription(func(quit <-chan struct{}) error {
            defer sub.Unsubscribe()
            for {
                select {
                case log := <-logs:
                    // New log arrived, parse the event and forward to the user
                    event := new({{$contract.Type}}{{.Normalized.Name}})
                    if err := _{{$contract.Type}}.contract.UnpackLog(event, "{{.Original.Name}}", log); err != nil {
                        return err
                    }
                    event.Raw = log

                    select {
                        case sink <- event:
                        case err := <-sub.Err():
                            return err
                        case <-quit:
                            return nil
                    }
                case err := <-sub.Err():
                    return err
                case <-quit:
                    return nil
                }
            }
        }), nil
    }
{{end}}{{end}}