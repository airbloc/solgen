{{define "contracts"}}
package {{.Package}}

import (
    "math/big"
    "strings"

    {{range $name, $import := .Imports}}{{$name}} "{{$import}}"
    {{end}})

{{template "wrapper" .Contract}}
{{end}}

{{define "wrapper"}}
    {{$contract := .}}{{$structs := .Structs}}

    // {{.Type}}ABI is the input ABI used to generate the binding from.
    const (
        {{.Type}}Address = "{{.Address}}"
        {{.Type}}TxHash = "{{.TxHash}}"
        {{.Type}}CreatedAt = "{{.CreatedAt}}"
        {{.Type}}ABI = "{{.InputABI}}"
    )

    // {{.Type}}Caller is an auto generated read-only Go binding around an Ethereum contract.
    type {{.Type}}Caller struct {
        contract *ablbind.BoundContract // Generic contract wrapper for the low level calls
    }

    func New{{.Type}}Caller(contract *ablbind.BoundContract) {{.Type}}Caller {
        return {{.Type}}Caller{contract: contract}
    }

    // {{.Type}}Transactor is an auto generated write-only Go binding around an Ethereum contract.
    type {{.Type}}Transactor struct {
        contract *ablbind.BoundContract // Generic contract wrapper for the low level calls
    }

    func New{{.Type}}Transactor(contract *ablbind.BoundContract) {{.Type}}Transactor {
        return {{.Type}}Transactor{contract: contract}
    }

    // {{.Type}}Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
    type {{.Type}}Filterer struct {
        contract *ablbind.BoundContract // Generic contract wrapper for the low level calls
    }

    func New{{.Type}}Filterer(contract *ablbind.BoundContract) {{.Type}}Filterer {
        return {{.Type}}Filterer{contract: contract}
    }

    {{range .Calls}}
        // {{.Normalized.Name}} is a free data retrieval call binding the contract method 0x{{printf "%x" .Original.ID}}.
        //
        // Solidity: {{formatmethod .Original $structs}}
        func (_{{$contract.Type}} *{{$contract.Type}}Caller) {{.Normalized.Name}}(opts *bind.CallOpts {{range .Normalized.Inputs}}, {{.Name}} {{bindtype .Type $structs}} {{end}}) ({{if .Structured}}struct{ {{range .Normalized.Outputs}}{{.Name}} {{bindtype .Type $structs}};{{end}} },{{else}}{{range .Normalized.Outputs}}{{bindtype .Type $structs}},{{end}}{{end}} error) {
            {{if .Structured}}ret := new(struct{
                {{range .Normalized.Outputs}}{{.Name}} {{bindtype .Type $structs}}
                {{end}}
        }){{else}}var (
            {{range $i, $_ := .Normalized.Outputs}}ret{{$i}} = new({{bindtype .Type $structs}})
            {{end}}
        ){{end}}
        out := {{if .Structured}}ret{{else}}{{if eq (len .Normalized.Outputs) 1}}ret0{{else}}&[]interface{}{
            {{range $i, $_ := .Normalized.Outputs}}ret{{$i}},
            {{end}}
        }{{end}}{{end}}
        err := _{{$contract.Type}}.contract.Call(opts, out, "{{.Original.Name}}" {{range .Normalized.Inputs}}, {{.Name}}{{end}})
        return {{if .Structured}}*ret,{{else}}{{range $i, $_ := .Normalized.Outputs}}*ret{{$i}},{{end}}{{end}} err
        }
    {{end}}

    {{range .Transacts}}
        // {{.Normalized.Name}} is a paid mutator transaction binding the contract method 0x{{printf "%x" .Original.ID}}.
        //
        // Solidity: {{formatmethod .Original $structs}}
        func (_{{$contract.Type}} *{{$contract.Type}}Transactor) {{.Normalized.Name}}(opts *ablbind.TransactOpts {{range .Normalized.Inputs}}, {{.Name}} {{bindtype .Type $structs}} {{end}}) (*chainTypes.Transaction, error) {
            return _{{$contract.Type}}.contract.Transact(opts, "{{.Original.Name}}" {{range .Normalized.Inputs}}, {{.Name}}{{end}})
        }
    {{end}}
    {{template "Events" .}}
{{end}}
