{{define "wrappers"}}
package {{.Package}}

import (
    "math/big"
    "strings"

    {{range $name, $import := .Imports}}{{$name}} "{{$import}}"
    {{end}})

{{$contract := .Contract}}
{{$structs := .Contract.Structs}}

//go:generate mockgen -source {{toSnakeCase $contract.Type}}.go -destination ./mocks/mock_{{toSnakeCase $contract.Type}}.go -package mocks I{{$contract.Type}}Contract

type I{{$contract.Type}}Calls interface { {{range $contract.Calls}}
    {{.Normalized.Name}}({{range .Normalized.Inputs}}
        {{.Name}} {{bindtype .Type $structs}},{{end}}
    ) ({{if .Structured}}struct{
        {{range .Normalized.Outputs}}{{.Name}} {{bindtype .Type $structs}};
        {{end}}
    },{{else}}{{range .Normalized.Outputs}}
        {{bindtype .Type $structs}},{{end}}
    {{end}} error,
    ){{end}}
}

type I{{$contract.Type}}Transacts interface { {{range $contract.Transacts}}
    {{.Normalized.Name}}(
        ctx context.Context,
        opts *ablbind.TransactOpts,
        {{range .Normalized.Inputs}}{{.Name}} {{bindtype .Type $structs}},
    {{end}}) (*chainTypes.Receipt, error){{end}}
}

type I{{$contract.Type}}Events interface {
    I{{$contract.Type}}Filterer
    I{{$contract.Type}}Parser
    I{{$contract.Type}}Watcher
}

type I{{$contract.Type}}Filterer interface { {{range $contract.Events}}
    Filter{{.Normalized.Name}}(
        opts *bind.FilterOpts,
        {{range .Normalized.Inputs}}{{if .Indexed}}{{.Name}} []{{bindtype .Type $structs}},{{end}}
    {{end}}) (ablbind.EventIterator, error){{end}}
}

type I{{$contract.Type}}Parser interface { {{range $contract.Events}}
    Parse{{.Normalized.Name}}(log chainTypes.Log) (*contracts.{{$contract.Type}}{{.Normalized.Name}}, error)
    Parse{{.Normalized.Name}}FromReceipt(receipt *chainTypes.Receipt) ([]*contracts.{{$contract.Type}}{{.Normalized.Name}}, error){{end}}
}

type I{{$contract.Type}}Watcher interface { {{range $contract.Events}}
    Watch{{.Normalized.Name}}(
        opts *bind.WatchOpts,
        sink chan<- *contracts.{{$contract.Type}}{{.Normalized.Name}},
        {{range .Normalized.Inputs}}{{if .Indexed}}{{.Name}} []{{bindtype .Type $structs}},{{end}}
    {{end}}) (event.Subscription, error){{end}}
}

type I{{$contract.Type}}Contract interface {
    Address() common.Address
    TxHash() common.Hash
    CreatedAt() *big.Int

    I{{$contract.Type}}Calls
    I{{$contract.Type}}Transacts
    I{{$contract.Type}}Events
}

// Manager is contract wrapper struct
type {{$contract.Type}}Contract struct {
    ablbind.Deployment
    client    ablbind.ContractBackend

    contracts.{{$contract.Type}}Caller
    contracts.{{$contract.Type}}Filterer
    contracts.{{$contract.Type}}Transactor
}

func New{{$contract.Type}}Contract(deployment ablbind.Deployment, backend ablbind.ContractBackend) interface{} {
    if deployment.Address() == (common.Address{}) {
        evmABI, err := abi.JSON(strings.NewReader(contracts.{{$contract.Type}}ABI))
        if err != nil {
            panic(err)
        }

        deployment = ablbind.NewDeployment(
            common.HexToAddress(contracts.{{$contract.Type}}Address),
            common.HexToHash(contracts.{{$contract.Type}}TxHash),
            new(big.Int).SetBytes(common.HexToHash(contracts.{{$contract.Type}}CreatedAt).Bytes()),
            evmABI,
        )
    }

    base := ablbind.NewBoundContract(deployment.Address(), deployment.ParsedABI, backend)

    contract := &{{$contract.Type}}Contract{
        Deployment: deployment,
        client:    backend,

        {{$contract.Type}}Caller: contracts.New{{$contract.Type}}Caller(base),
        {{$contract.Type}}Transactor: contracts.New{{$contract.Type}}Transactor(base),
        {{$contract.Type}}Filterer: contracts.New{{$contract.Type}}Filterer(base),
    }

    return contract
}

func (c *{{$contract.Type}}Contract) GetSelectors() map[string]string {
    selectors := make(map[string]string)
    {{range $contract.Calls}}selectors["0x{{printf "%x" .Original.ID}}"] = "{{.Original.Sig}}"
    {{end}}
    {{range $contract.Transacts}}selectors["0x{{printf "%x" .Original.ID}}"] = "{{.Original.Sig}}"
    {{end}}
    return selectors
}

{{range $contract.Calls}}
// {{.Normalized.Name}} is a free data retrieval call binding the contract method 0x{{printf "%x" .Original.ID}}.
//
// Solidity: {{.Original.String}}
func (c *{{$contract.Type}}Contract) {{.Normalized.Name}}(
    {{range .Normalized.Inputs}}{{.Name}} {{bindtype .Type $structs}},
{{end}}) (
    {{if .Structured}}struct{
        {{range .Normalized.Outputs}}{{.Name}} {{bindtype .Type $structs}};
        {{end}}
    },{{else}}{{range .Normalized.Outputs}}
        {{bindtype .Type $structs}},{{end}}
    {{end}} error,
) {
    return c.{{$contract.Type}}Caller.{{.Normalized.Name}}(nil{{range .Normalized.Inputs}}, {{.Name}}{{end}})
}
{{end}}

{{range $contract.Transacts}}
// {{.Normalized.Name}} is a paid mutator transaction binding the contract method 0x{{printf "%x" .Original.ID}}.
//
// Solidity: {{.Original.String}}
func (c *{{$contract.Type}}Contract) {{.Normalized.Name}}(
    ctx context.Context,
    opts *ablbind.TransactOpts,
    {{range .Normalized.Inputs}}{{.Name}} {{bindtype .Type $structs}},
{{end}}) (*chainTypes.Receipt, error) {
    tx, err := c.{{$contract.Type}}Transactor.{{.Normalized.Name}}(c.client.Transactor(ctx, opts){{range .Normalized.Inputs}}, {{.Name}}{{end}})
    if err != nil {
        return nil, err
    }
    return c.client.WaitMined(ctx, tx)
}
{{end}}{{end}}
