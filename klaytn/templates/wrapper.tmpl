{{define "Wrapper"}}
// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package {{.Package}}

import (
    "math/big"
    "strings"

    "github.com/airbloc/airbloc-go/shared/blockchain"
    "github.com/airbloc/airbloc-go/shared/types"
    "github.com/klaytn/klaytn/accounts/abi"
    "github.com/klaytn/klaytn/accounts/abi/bind"
    "github.com/klaytn/klaytn/common"
    "github.com/klaytn/klaytn/event"
    klaytn "github.com/klaytn/klaytn"
    klayTypes "github.com/klaytn/klaytn/blockchain/types"
)

{{$contract := .Contract}}

//go:generate mockgen -source {{toSnakeCase $contract.Type}}_wrapper.go -destination ./mocks/mock_{{toSnakeCase $contract.Type}}.go -package mocks I{{$contract.Type}}Manager,I{{$contract.Type}}Contract
type I{{$contract.Type}}Manager interface {
    Address() common.Address
    TxHash() common.Hash
    CreatedAt() *big.Int

    // Call methods
    I{{$contract.Type}}Calls

    // Transact methods
    {{range $contract.Transacts}}{{.Normalized.Name}}(ctx context.Context, {{.InputArgs true}}) ({{if gt (len .Normalized.Outputs) 0}}{{.OutputArgs}},{{end}} error)
    {{end}}

    // Event methods
    I{{$contract.Type}}Filterer
    I{{$contract.Type}}Watcher
}

type I{{$contract.Type}}Calls interface { {{range $contract.Calls}}
    {{.Normalized.Name}}({{.InputArgs true}}) ({{.OutputArgs}}, error){{end}}
}

type I{{$contract.Type}}Transacts interface { {{range $contract.Transacts}}
    {{.Normalized.Name}}(ctx context.Context, {{.InputArgs true}}) (*klayTypes.Receipt, error){{end}}
}

type I{{$contract.Type}}Events interface {
    I{{$contract.Type}}Filterer
    I{{$contract.Type}}Parser
    I{{$contract.Type}}Watcher
}

type I{{$contract.Type}}Filterer interface { {{range $contract.Events}}
    Filter{{.Normalized.Name}}(opts *bind.FilterOpts{{range .Normalized.Inputs}}{{if .Indexed}}, {{.Name}} []{{bindType .Type $contract.TypeOption}}{{end}}{{end}}) (*{{$contract.Type}}{{.Normalized.Name}}Iterator, error){{end}}
}

type I{{$contract.Type}}Parser interface { {{range $contract.Events}}
    Parse{{.Normalized.Name}}FromReceipt(receipt *klayTypes.Receipt) (*{{$contract.Type}}{{.Normalized.Name}}, error){{end}}
}

type I{{$contract.Type}}Watcher interface { {{range $contract.Events}}
    Watch{{.Normalized.Name}}(opts *bind.WatchOpts, sink chan<- *{{$contract.Type}}{{.Normalized.Name}}{{range .Normalized.Inputs}}{{if .Indexed}}, {{.Name}} []{{bindType .Type $contract.TypeOption}}{{end}}{{end}}) (event.Subscription, error){{end}}
}

type I{{$contract.Type}}Contract interface {
    Address() common.Address
    TxHash() common.Hash
    CreatedAt() *big.Int

    I{{$contract.Type}}Calls
    I{{$contract.Type}}Transacts
    I{{$contract.Type}}Events
}

// Manager is contract wrapper struct
type {{$contract.Type}}Contract struct {
    address   common.Address
    txHash    common.Hash
    createdAt *big.Int
    client    blockchain.TxClient

    {{$contract.Type}}Caller
    {{$contract.Type}}Filterer
    {{$contract.Type}}Transactor
}

// Address is getter method of Accounts.address
func (c *{{$contract.Type}}Contract) Address() common.Address {
    return c.address
}

// TxHash is getter method of Accounts.txHash
func (c *{{$contract.Type}}Contract) TxHash() common.Hash {
    return c.txHash
}

// CreatedAt is getter method of Accounts.createdAt
func (c *{{$contract.Type}}Contract) CreatedAt() *big.Int {
    return c.createdAt
}

func new{{$contract.Type}}Contract(address common.Address, txHash common.Hash, createdAt *big.Int, parsedABI abi.ABI, backend bind.ContractBackend) interface{} {
    contract := bind.NewBoundContract(address, parsedABI, backend, backend, backend)

    return &{{$contract.Type}}Contract{
        address:   address,
        txHash:    txHash,
        createdAt: createdAt,
        client:    backend.(blockchain.TxClient),

        {{$contract.Type}}Caller: {{$contract.Type}}Caller{contract: contract},
        {{$contract.Type}}Transactor: {{$contract.Type}}Transactor{contract: contract},
        {{$contract.Type}}Filterer: {{$contract.Type}}Filterer{contract: contract},
    }
}

// convenient hacks for blockchain.Client
func init() {
    blockchain.AddContractConstructor("{{$contract.Type}}", new{{$contract.Type}}Contract)
    {{range $contract.Transacts}}blockchain.RegisterSelector("0x{{printf "%x" .Original.Id}}", "{{.Original.Sig}}")
{{end}}}

{{range $contract.Calls}}
// {{.Normalized.Name}} is a free data retrieval call binding the contract method 0x{{printf "%x" .Original.Id}}.
//
// Solidity: {{.Original.String}}
func (c *{{$contract.Type}}Contract) {{.Normalized.Name}}({{.InputArgs true}}) ({{.OutputArgs}}, error) {
    return c.{{$contract.Type}}Caller.{{.Normalized.Name}}(nil, {{.InputArgs false}})
}
{{end}}

{{range $contract.Transacts}}
// {{.Normalized.Name}} is a paid mutator transaction binding the contract method 0x{{printf "%x" .Original.Id}}.
//
// Solidity: {{.Original.String}}
func (c *{{$contract.Type}}Contract) {{.Normalized.Name}}(ctx context.Context, {{.InputArgs true}}) (*klayTypes.Receipt, error) {
    tx, err := c.{{$contract.Type}}Transactor.{{.Normalized.Name}}(c.client.Account(), {{.InputArgs false}})
    if err != nil {
        return nil, err
    }
    return c.client.WaitMined(ctx, tx)
}
{{end}}{{end}}